# Copyright (c) 2023 Graphcore Ltd. All rights reserved.
from abc import ABC, abstractmethod
from datetime import datetime
import logging
from typing import Any, List


logger = logging.getLogger("ssf")

from ssf.utils import lookup_dict
from ssf.version import VERSION
from ssf.config import SSFConfig
from ssf.results import SSFExceptionInternalError


class TemplateSymbolParser(ABC):
    @abstractmethod
    def parse(self, symbol_id: str, indent: int = 0) -> str:
        """
        Parameters:
                symbol_id (str): Text symbol that should be replaced with some other text.
                indent (int): A count of whitespace prefixing the line containing the symbol; this can be
                        used to maintain block indententation if the replacement text is multi-line.
        Returns:
                Replacement text as a string, if the symbol_id is known.
                None if symbol_id not known.
        """


class ConfigSymbolParser(TemplateSymbolParser):
    def __init__(self, ssf_config: SSFConfig):
        self.ssf_config = ssf_config

    def parse(self, symbol_id: str, indent: int = 0) -> str:
        # Where symbols have syntax ".... {{config.api.name}} ...."
        # Will be replaced with lookup into the config namespace.
        if symbol_id.find("config.") == 0:
            return lookup_dict(self.ssf_config, symbol_id, namespaced=True)
        return None


class AutogeneratedSymbolParser(TemplateSymbolParser):
    def parse(self, symbol_id: str, indent: int = 0) -> str:
        # Where symbol has syntax ".... {{autogenerated}} ...."
        # Will be replaced with comments indicated file is auto-generated (with timestamp and version).
        if symbol_id.find("autogenerated") == 0:
            timestamp = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            return (
                f"# ** DO NOT EDIT **\n"
                f"# Auto-generated by Simple Server Framework\n"
                f"# Version: {VERSION}\n"
                f"# Timestamp: {timestamp}"
            )
        return None


def expand_template(
    ssf_config: SSFConfig,
    template_filename: str,
    expanded_filename: str,
    custom_parsers: List[TemplateSymbolParser] = [],
):
    with open(template_filename, "rt") as template:
        with open(expanded_filename, "wt") as output:

            parsers = []

            # Add built-in/common parsers
            parsers.append(AutogeneratedSymbolParser())
            parsers.append(ConfigSymbolParser(ssf_config))

            # Add caller's custom parsers
            if custom_parsers:
                parsers += custom_parsers

            for line in template:

                # Parse symbols.
                while True:
                    sym_begin = line.find("{{")
                    if sym_begin < 0:
                        break
                    sym_end = sym_begin + 2 + line[sym_begin + 2 :].find("}}") + 1
                    if sym_end < 0:
                        raise SSFExceptionInternalError(
                            f"Failed to find closing brackets for symbol beginning at position {sym_begin} in {template_filename}, line {line}"
                        )
                    symbol = line[sym_begin + 2 : sym_end - 1]
                    indent = len(line) - len(line.lstrip())

                    logger.debug(f"Parsing {symbol}")

                    insert_lines = None
                    for parser in parsers:
                        insert_lines = parser.parse(symbol, indent)
                        if insert_lines is not None:
                            break

                    if insert_lines is None:
                        raise SSFExceptionInternalError(
                            f"Failed to replace template symbol {symbol} at position {sym_begin} in {template_filename}, line {line}"
                        )

                    logger.debug(f"insert_lines={insert_lines}")

                    new_line = line[0:sym_begin] + insert_lines + line[sym_end + 1 :]
                    line = new_line

                if len(line.strip()) == 0:
                    output.write("\n")
                else:
                    output.write(line)
